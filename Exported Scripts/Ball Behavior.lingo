global gMaxBallSprite -- highest sprite channel number which has a ball behavior. Assigned here and in Reinitialize for Levelglobal gPlayer -- The player behavior. Assigned by Player Behavior scriptglobal gLevelRunning -- whether things are under player/physics controlglobal gSndChanCollide -- our sound channel allocation (constant)property pAngVel -- just used for decorationproperty pAngproperty pPos -- floating-point version of position of sprite, so we can do slow motionsproperty pVel -- velocity of ball in pixels/frameproperty spriteNumon beginSprite me  mySprite = sprite(me.spriteNum)    -- update with our sprite num  gMaxBallSprite = max(gMaxBallSprite, me.spriteNum)    pVel = vector(0,0,0)  pPos = vector(mySprite.locH, mySprite.locV, 0)  pAngVel = (random(50) - 20) / 20.0  pAng = random(360)endon exitFrame me    -- name some things we'll use frequently  mySprite = sprite(me.spriteNum)  bounds = (the stage).rect    if not gLevelRunning then    mySprite.puppet = FALSE    -- If the level is not currently running, then sprites move by Director control, not ours    pPos = vector(mySprite.locH, mySprite.locV, 0)    pVel = vector(0,0,0)    return  end if    -- Ordinary objects wrap around the screen.  -- XXX No they don't -- because teleporting them one at a time breaks glues, which I don't care to fix right now.  if FALSE and mySprite.name <> "Weapon" then    if mySprite.rect.left > bounds.width and pVel.x > 0 then      pPos.x = pPos.x - bounds.width * 2    end if    if mySprite.rect.right < 0 and pVel.x < 0 then      pPos.x = pPos.x + bounds.width * 2    end if    if mySprite.rect.bottom < 0 and pVel.y < 0 then      pPos.y = pPos.y + bounds.height * 2    end if    if mySprite.rect.top > bounds.height  and pVel.y > 0 then      pPos.y = pPos.y - bounds.height * 2    end if  end if    thisMass = power(mySprite.width, 2)    -- Check for bouncing off other balls  repeat with otherNum = me.spriteNum + 1 to gMaxBallSprite    if not mySprite.intersects(otherNum) then next repeat -- fast skip        otherSprite = sprite(otherNum)        -- find the other sprite's ball behavior, if it has one, else skip it    oBeh = findInstance(otherSprite, "Ball Behavior")    if oBeh = VOID then       next repeat    end if        -- the player does not collide with their weapon    if mySprite.name = "Player" and otherSprite.name = "Weapon" \      or (mySprite.name = "Weapon" or mySprite.name = "Player") and otherSprite.name = "Playerbit" then       next repeat    end if        --- Done with early exits, now actual collision logic ---        otherLoc = otherSprite.loc    -- Compute the relative position of the other sprite    deltaX = otherLoc.locH - mySprite.locH    deltaY = otherLoc.locV - mySprite.locV        -- compute radius from display size (assumed circular)    myRadius = mySprite.width / 2    otherRadius = otherSprite.width / 2        -- If we are actually in collision on the circle boundary (this is comparing distance-squared to radius-squared)    if deltaX*deltaX + deltaY*deltaY < power(myRadius + otherRadius, 2) then            if mySprite.name = "Player" and otherSprite.name <> "Playerbit" or otherSprite.name = "Player" then        call(#die, gPlayer) -- XXX should get the player behavior from sprite instead        return      end if            -- find the direction of the other sprite      angle = atan2(deltaY, deltaX)            -- find our velocity relative to the direction of the other sprite      -- velRel.locH is the 'towards' component and velRel.locV is the 'perpendicular' component      velRel = rotvec(pVel - oBeh.pVel, angle)      -- if it is towards,      if velRel.x > 0 then        -- then there is an actual collision                -- Sound        sound(gSndChanCollide).volume = min(power(velRel.x, 2), 255)        if (sound(gSndChanCollide).volume > 2) then          puppetSound gSndChanCollide, "Bomp"        end if                otherMass = power(otherSprite.width, 2)                impulseMag = 2.0 * velRel.x / (1.0/thisMass + 1.0/otherMass)        impulse = vector(impulseMag*cos(angle), impulseMag*sin(angle), 0)        --put impulse.x / thisMass        pVel = vector(pVel.x - impulse.x / thisMass, pVel.y - impulse.y / thisMass, 0)                oBeh.pVel = vector(oBeh.pVel.x + impulse.x / otherMass, oBeh.pVel.y + impulse.y / otherMass, 0)      end if    end if  end repeat    -- Update position with velocity  pPos = pPos + pVel    -- Update onscreen position with high-res position  mySprite.loc = point(pPos.x, pPos.y)    -- We don't simulate angular velocity in collisions - this is just for decoration  --pAng = pAng + pAngVel  --mySprite.rotation = pAngend-- called by player behavioron accelerate me, deltaV  pVel = pVel + deltaVendon damp me, factor  pVel = pVel * factorend-- Returns random numbers suitable for ball velocitieson randomVel  return randomMagnitude() * randomSign()end-- Returns random positive numbers suitable for ball velocitieson randomMagnitude  return exp(-random(100) / 100.0) * 10.0end-- Returns -1 to 1on randomSign  return random(2) * 2 - 3endon getVel  return pVelend