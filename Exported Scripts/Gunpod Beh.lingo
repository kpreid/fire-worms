-- This is not an enemy, but a part of one. If notified of breakage, it stops shooting.global gSndChanBulletsglobal gFirstBulletSpriteglobal gLevelRunningproperty pFirePhaseproperty pFirePeriodproperty pFireCountproperty pFireSpacingproperty pDependsOnproperty pAliveon getPropertyDescriptionList me  return [#pFirePeriod: [#comment: "Fires a group every (this) frames:", #format: #integer, #default: 70], \          #pFireCount: [#comment: "Bullets per group:", #format: #integer, #default: 5], \          #pFireSpacing: [#comment: "Fires a bullet every (this) frames:", #format: #integer, #default: 2], \          #pFirePhase: [#comment: "Initial phase in frames:", #format: #integer, #default: 0], \          #pDependsOn: [#comment: "Stops when this sprite offset's behavior 2 is dead:", #format: #integer, #default: 0]]endon beginSprite me  pAlive = trueendon exitFrame me  -- Horrible kludge: this sprite looks at that sprite's SECOND behavior (assumed to be an enemy behavior or this behavior)'s pAlive.  -- I would write this in a much better way if I had time to build the infrastructure for it.  if not sprite(me.spriteNum + pDependsOn).scriptInstanceList[2].pAlive or not gLevelRunning then    return  end if    physics = sprite(me.spriteNum).scriptInstanceList[1]    -- find direction to fire  deltaPos = vector((the mouseLoc.locH), (the mouseLoc).locV, 0) - physics.pPos  direction = deltaPos.getNormalized()    -- update appearance  sprite(me.spriteNum).rotation = atan2(deltaPos.y, deltaPos.x) * 180 / pi    -- check if it's time to fire  pFirePhase = (pFirePhase + 1) mod pFirePeriod  if pFirePhase >= pFireCount * pFireSpacing or pFirePhase mod pFireSpacing <> 0 then return    -- initialize a bullet sprite  s = findFreeSprite()  if s = VOID then return -- not enough space in the score for more bullets  s.puppet = TRUE  s.member = member "Bullet"  bpos = physics.pPos + direction * 20  s.loc = point(bpos.x, bpos.y)  s.ink = 36    -- attach behaviors to bullet sprite  bb = new(script "Ball Behavior")  bb.spriteNum = s.spriteNum  s.scriptInstanceList.add(bb)  beginSprite bb  bb.pVel = direction * 15 -- XXX this velocity should be relative to our motion, and yet aimed correctly    bub = new(script "Bullet Behavior")  bub.spriteNum = s.spriteNum  s.scriptInstanceList.add(bub)  beginSprite bub    -- play sound  sound(gSndChanBullets).volume = 200  puppetSound gSndChanBullets, "Boiw"      endon notifyGlueBroken me, glue  pAlive = falseendon findFreeSprite  repeat with i = gFirstBulletSprite to the lastChannel do    if sprite(i).puppet = false then      return sprite(i)    end if  end repeat  return VOIDend